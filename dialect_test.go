package sqlparser_test

import (
	"strings"
	"testing"

	sqlparser "github.com/oarkflow/sqlparser"
)

func TestConvertDialectSelectPostgres(t *testing.T) {
	out, err := sqlparser.ConvertDialect("SELECT id, name FROM users WHERE id = ?", sqlparser.DialectPostgres)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	if !strings.Contains(out, `"users"`) {
		t.Fatalf("expected postgres quoted identifier, got: %s", out)
	}
	if !strings.Contains(out, "$1") {
		t.Fatalf("expected postgres placeholder conversion, got: %s", out)
	}
}

func TestConvertDialectMySQLQuotes(t *testing.T) {
	out, err := sqlparser.ConvertDialect(`SELECT "Name" FROM "Users"`, sqlparser.DialectMySQL)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	if !strings.Contains(out, "`Name`") || !strings.Contains(out, "`Users`") {
		t.Fatalf("expected mysql backtick quoting, got: %s", out)
	}
}

func TestConvertDialectJSONBToMySQL(t *testing.T) {
	out, err := sqlparser.ConvertDialect(`CREATE TABLE events (payload JSONB)`, sqlparser.DialectMySQL)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	if !strings.Contains(strings.ToUpper(out), "JSON)") {
		t.Fatalf("expected JSONB to map to JSON for mysql, got: %s", out)
	}
}

func TestConvertDialectJSONBToSQLite(t *testing.T) {
	out, err := sqlparser.ConvertDialect(`CREATE TABLE events (payload JSONB)`, sqlparser.DialectSQLite)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	if !strings.Contains(strings.ToUpper(out), "TEXT)") {
		t.Fatalf("expected JSONB to map to TEXT for sqlite, got: %s", out)
	}
}

func TestConvertDialectJSONBOperators(t *testing.T) {
	in := `SELECT payload->>'user', payload#>>'{a,b}' FROM events WHERE payload @> '{"x":1}' AND payload ? 'user'`
	out, err := sqlparser.ConvertDialect(in, sqlparser.DialectPostgres)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	for _, op := range []string{"->>", "#>>", "@>", "?"} {
		if !strings.Contains(out, op) {
			t.Fatalf("expected operator %s in output: %s", op, out)
		}
	}
}

func TestConvertDialectWithInsert(t *testing.T) {
	in := `WITH src AS (SELECT id FROM users WHERE id = ?) INSERT INTO logs (id) SELECT id FROM src`
	out, err := sqlparser.ConvertDialect(in, sqlparser.DialectPostgres)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	if !strings.Contains(out, "WITH") || !strings.Contains(out, "INSERT INTO") {
		t.Fatalf("expected CTE + insert, got: %s", out)
	}
}

func TestConvertFunctionRewrite(t *testing.T) {
	out, err := sqlparser.ConvertDialect(`SELECT IFNULL(name, 'x') FROM users`, sqlparser.DialectPostgres)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	if !strings.Contains(out, "COALESCE(") {
		t.Fatalf("expected IFNULL->COALESCE rewrite, got: %s", out)
	}
	out, err = sqlparser.ConvertDialect(`SELECT COALESCE(name, 'x') FROM users`, sqlparser.DialectMySQL)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	if !strings.Contains(out, "IFNULL(") {
		t.Fatalf("expected COALESCE->IFNULL rewrite, got: %s", out)
	}
}

func TestConvertOnDupKeyToOnConflict(t *testing.T) {
	in := `INSERT INTO users (id, name) VALUES (1, 'a') ON DUPLICATE KEY UPDATE name = 'b'`
	out, err := sqlparser.ConvertDialect(in, sqlparser.DialectPostgres)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	if !strings.Contains(out, "ON CONFLICT") || !strings.Contains(out, "DO UPDATE SET") {
		t.Fatalf("expected ON DUPLICATE KEY -> ON CONFLICT rewrite, got: %s", out)
	}
}

func TestConvertOnConflictToOnDupKey(t *testing.T) {
	in := `INSERT INTO users (id, name) VALUES (1, 'a') ON CONFLICT (id) DO UPDATE SET name = 'b'`
	out, err := sqlparser.ConvertDialect(in, sqlparser.DialectMySQL)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	if !strings.Contains(out, "ON DUPLICATE KEY UPDATE") {
		t.Fatalf("expected ON CONFLICT -> ON DUPLICATE KEY rewrite, got: %s", out)
	}
}

func TestConvertAutoIncrementToIdentity(t *testing.T) {
	in := `CREATE TABLE users (id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(32))`
	out, err := sqlparser.ConvertDialect(in, sqlparser.DialectPostgres)
	if err != nil {
		t.Fatalf("convert failed: %v", err)
	}
	if !strings.Contains(out, "GENERATED BY DEFAULT AS IDENTITY") {
		t.Fatalf("expected AUTO_INCREMENT->IDENTITY rewrite, got: %s", out)
	}
}
